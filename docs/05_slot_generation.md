# Алгоритм расчёта свободных слотов

Цель: вернуть список свободного времени для выбранной даты, мастера и услуги.

Вход:
- date (YYYY-MM-DD)
- service_id (длительность услуги)
- barber_id (optional, если нужно “первый свободный”)
- slot_step (например 30 минут)

Источники данных:
- working_hours (по локации)
- barber_working_hours (опционально, приоритетнее)
- time_off (выходные/перерывы)
- appointments (pending/confirmed)

## Правила
1) Время слотов округляется по шагу slot_step.
2) Учитываются только активные записи (pending/confirmed).
3) Слот доступен, если полностью помещается в рабочее время и не пересекается с time_off и активными записями.
4) Если есть персональный график мастера (barber_working_hours), используем его; иначе — общий график локации.

## Псевдокод

1. Определить рабочий интервал дня:
- Если есть barber_working_hours на этот weekday → взять его
- Иначе взять working_hours локации

2. Построить список интервалов “нельзя”:
- time_off мастера в этот день
- appointments мастера (pending/confirmed) в этот день

3. Итерация по времени:
- Начало = open_time
- Пока start + duration <= close_time:
  - if слот пересекается с “нельзя” → пропускаем
  - else добавляем слот
  - start += slot_step

## Edge cases
- Рабочий день может пересекать полуночь (если будет ночной график) — можно поддержать позже.
- Если услуга 90 мин, а шаг 30 мин: слот 10:00 занимает до 11:30.
- При переносе проверяем, что новый слот не пересекается с другими записями.

## Рекомендуемая защита от гонок
Использовать серверную функцию (RPC), которая:
- внутри транзакции проверяет пересечения
- делает INSERT
- ловит конфликт exclusion constraint и возвращает ошибку “slot_taken”
